<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pomodoro</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <style>
    :root {
      --bg: #f7fbff;
      --panel: #ffffff;
      --muted: #6b7280;
      --accent: #2563eb;
      --accent-2: #f97316;
      --focus: #2563eb;
      --break: #f59e0b;
      --text: #0f172a;
    }
    * { box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, system-ui, sans-serif;
      background:
        radial-gradient(140% 140% at 15% 20%, rgba(37,99,235,0.15), transparent),
        radial-gradient(160% 140% at 85% 10%, rgba(249,115,22,0.12), transparent),
        var(--bg);
      color: var(--text);
      max-width: 720px;
      margin: 32px auto 48px;
      padding: 0 18px 32px;
    }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    h1 { margin-bottom: 8px; }
    .card {
      background: linear-gradient(160deg, rgba(255,255,255,0.95), rgba(255,255,255,0.88));
      border: 1px solid rgba(15,23,42,0.05);
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 12px 32px rgba(15,23,42,0.08);
    }
    #time {
      font-size: 72px;
      font-weight: 800;
      letter-spacing: 1px;
      margin: 12px 0 10px;
      color: var(--accent);
      text-shadow: 0 6px 18px rgba(37,99,235,0.25);
    }
    .subtle { color: var(--muted); }
    .buttons { display:flex; gap:10px; flex-wrap:wrap; margin-top: 12px; }
    button {
      padding: 12px 16px;
      font-size: 16px;
      border-radius: 12px;
      border: 1px solid transparent;
      cursor: pointer;
      font-weight: 600;
      transition: transform 0.08s ease, box-shadow 0.12s ease, opacity 0.2s;
    }
    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }
    .btn-focus {
      background: linear-gradient(120deg, var(--accent), #60a5fa);
      color: #f8fafc;
      box-shadow: 0 8px 18px rgba(37,99,235,0.25);
    }
    .btn-break {
      background: linear-gradient(120deg, var(--accent-2), #fdba74);
      color: #0f172a;
      box-shadow: 0 8px 18px rgba(249,115,22,0.25);
    }
    .btn-neutral {
      background: #e5e7eb;
      color: #111827;
      border-color: rgba(15,23,42,0.08);
    }
  </style>
</head>
<body>
  
  {% if user_id %}
  <p>
    <a href="/history" class="btn btn-primary btn-sm shadow-sm" style="border-radius:12px;">View history</a>
    <a href="/logout" class="btn btn-outline-secondary btn-sm shadow-sm" style="border-radius:12px;">Logout</a>
  </p>
{% else %}
  <p>
    <a href="/login" class="btn btn-primary btn-sm shadow-sm" style="border-radius:12px;">Login</a>
    <a href="/register" class="btn btn-outline-secondary btn-sm shadow-sm" style="border-radius:12px;">Register</a>
  </p>
{% endif %}
  <div class="card">
    <h1>Pomodoro</h1>
    <p class="subtle" style="margin-bottom: 10px;">
      New to this method?
      <a href="/about-pomodoro">What is the Pomodoro technique?</a>
    </p>
    <div id="label" style="font-weight:700; margin-top:4px;"></div>
    <div id="counter" class="subtle" style="margin-bottom:4px;"></div>
    <div id="time">25:00</div>
    <div class="buttons">
      <button id="startFocus" class="btn-focus">Start focus</button>
      <button id="startBreak" class="btn-break" disabled>Start break</button>
      <button id="pause" class="btn-neutral" disabled>Pause</button>
      <button id="reset" class="btn-neutral">Reset</button>
    </div>
  </div>
<script>
  // ===== Pomodoro (manual advance) =====
  // Controls: Start focus / Start break / Pause / Reset
  // - No auto-advance
  // - Friendly chime on completion
  // - Safari/background-tab resilient via wall-clock timing
  // - Logs completed FOCUS blocks to /api/log (SQLite)

  const DURATIONS = {
    focus: 25*60,
    short_break: 5*60,
    long_break: 15*60
  };

  // --- State ---
  let mode = null;                 // null | "focus" | "short_break" | "long_break"
  let focusCountInCycle = 0;       // 0..4; long break after 4 completed focuses
  let remaining = 0;               // seconds
  let running = false;
  let timerId = null;
  let completionHandled = false;

  // Wall-clock start time for current run (ms since epoch)
  let startedAtMs = null;

  // --- Elements ---
  const timeEl = document.getElementById("time");
  const startFocusBtn = document.getElementById("startFocus");
  const startBreakBtn = document.getElementById("startBreak");
  const pauseBtn = document.getElementById("pause");
  const resetBtn = document.getElementById("reset");

  // Optional elements 
  const labelEl = document.getElementById("label");
  const counterEl = document.getElementById("counter");

  // --- Helpers ---
  function formatTime(seconds) {
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
  }

  function modeLabel(m) {
    if (m === "focus") return "Focus";
    if (m === "short_break") return "Short break";
    if (m === "long_break") return "Long break";
    return "Idle";
  }

  // Friendly chime (WebAudio) with a persistent, user-unlocked AudioContext.
  let audioCtx = null;
  async function ensureAudioCtx() {
    if (!audioCtx) {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioCtx();
    }
    if (audioCtx.state === "suspended") {
      try { await audioCtx.resume(); } catch (e) { /* ignore */ }
    }
    return audioCtx;
  }

  // Prime audio on first user gesture so browsers allow playback.
  const unlock = () => { ensureAudioCtx(); document.removeEventListener("pointerdown", unlock); };
  document.addEventListener("pointerdown", unlock, { once: true });

  // Play a short two-note chime. Safe to call after ensureAudioCtx().
  function chime() {
    try {
      ensureAudioCtx().then((ctx) => {
        const now = ctx.currentTime;
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.2, now + 0.03);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.9);
        gain.connect(ctx.destination);

        const o1 = ctx.createOscillator();
        o1.type = "sine";
        o1.frequency.setValueAtTime(880, now);

        const o2 = ctx.createOscillator();
        o2.type = "sine";
        o2.frequency.setValueAtTime(660, now + 0.14);

        o1.connect(gain);
        o2.connect(gain);

        o1.start(now);
        o1.stop(now + 0.22);
        o2.start(now + 0.14);
        o2.stop(now + 0.6);
      });
    } catch (e) {
      // ignore silently
    }
  }

  function render() {
    // Display time
    timeEl.textContent = formatTime(remaining);

    // Labels/counters (optional)
    if (labelEl) labelEl.textContent = modeLabel(mode);
    if (counterEl) counterEl.textContent = `Focus blocks this cycle: ${focusCountInCycle}/4`;

    // Pause enabled only while running
    pauseBtn.disabled = !running;

    // Allow exactly one next action when idle:
    // - After a focus finishes -> only break is enabled
    // - After a break finishes -> only focus is enabled
    // - Fresh/reset -> focus enabled
    startFocusBtn.disabled = running || (mode === "focus" && remaining === 0);
    startBreakBtn.disabled = running || !(mode === "focus" && remaining === 0 && focusCountInCycle > 0);
  }

  function stopTimer() {
    running = false;
    startedAtMs = null;
    if (timerId !== null) {
      clearInterval(timerId);
      timerId = null;
    }
    render();
  }

  function computeRemaining() {
    const total = DURATIONS[mode];
    const elapsed = Math.floor((Date.now() - startedAtMs) / 1000);
    remaining = Math.max(total - elapsed, 0);
  }

  async function logPomodoroCompleted(durationSeconds) {
  console.log("Logging pomodoro to /api/log ...", { durationSeconds });

  const res = await fetch("/api/log", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ type: "focus", duration_seconds: durationSeconds })
  });

  if (!res.ok) {
    const text = await res.text();
    console.warn("Log failed:", res.status, text);
  } else {
    console.log("Log ok");
  }
}



  async function complete() {
  if (completionHandled) return;
  completionHandled = true;

  stopTimer();
  chime();

  if (mode === "focus") {
    focusCountInCycle += 1;
    await logPomodoroCompleted(DURATIONS.focus);
  }

  render();
}


  function tick() {
    if (!running) return;

    computeRemaining();
    render();

    if (remaining === 0) {
      // prevent double-fire
      running = false;
      if (timerId !== null) {
        clearInterval(timerId);
        timerId = null;
      }
      complete();
    }
  }

  function start(modeToStart) {
    if (running) return;
    completionHandled = false;

    mode = modeToStart;
    remaining = DURATIONS[mode];
    startedAtMs = Date.now();
    running = true;

    timerId = setInterval(tick, 250);
    tick(); // immediate update
  }

  function startFocus() {
    start("focus");
  }

  function startBreak() {
    // Only valid after a completed focus block
    if (running) return;
    if (mode !== "focus" || remaining !== 0 || focusCountInCycle <= 0) return;

    const breakType = (focusCountInCycle >= 4) ? "long_break" : "short_break";

    // If weâ€™re starting the long break, reset the cycle counter right away
    // (Alternative would be resetting after long break completes.)
    if (breakType === "long_break") focusCountInCycle = 0;

    start(breakType);
  }

  function pause() {
    if (!running) return;
    computeRemaining();  // capture accurate remaining before stopping
    stopTimer();         // stops interval + keeps remaining frozen
  }

  function reset() {
    stopTimer();
    mode = null;
    focusCountInCycle = 0;
    remaining = 0; // show 00:00 when idle
    render();
  }

  // --- Wire up ---
  startFocusBtn.addEventListener("click", startFocus);
  startBreakBtn.addEventListener("click", startBreak);
  pauseBtn.addEventListener("click", pause);
  resetBtn.addEventListener("click", reset);

  // Initial UI state
  reset();
</script>
</body>
</html>
